<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Asistencia Inkspired — Multilenguaje (estable)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Inter',sans-serif;background:#f0f2f5;color:#111;margin:0;height:100vh;display:flex;flex-direction:column;}
    .center-screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:20px; text-align: center;}
    .panel{background:#fff;padding:20px;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,0.08);max-width:920px;width:100%;}
    .top-bar{display:flex;justify-content:flex-end;padding:12px 16px;}
    .small-note{font-size:12px;color:#6b7280;}
    .chat-container{flex:1;overflow:auto;padding:16px;background:#f8fafc;}
    .message-bubble{max-width:80%;padding:.75rem 1rem;border-radius:1rem;margin-bottom:.5rem;word-wrap:break-word; position: relative;}
    .agent-bubble{background:#fff;color:#111;align-self:flex-start;border:1px solid #e5e7eb;}
    .user-bubble{background:#e9f5ff;color:#111;align-self:flex-end;margin-left:auto;border:1px solid #bae6fd;}
    .system-bubble{background:#fff7ed;color:#744210;text-align:center;align-self:center;padding:.5rem .75rem;border-radius:.75rem;border:1px solid #fcd34d;}
    .controls{display:flex;gap:.5rem;align-items:center;}
    select.lang-select{padding:.35rem .6rem;border:1px solid #e5e7eb;border-radius:.5rem;background:#fff;}
    input[type="text"], input[type="password"]{padding:.6rem .8rem;border-radius:999px;border:1px solid #e5e7eb;background:#f3f4f6;outline:none;width:100%;}
    button.btn{padding:.6rem .9rem;border-radius:999px;border:none;cursor:pointer;}
    button.btn:disabled{opacity:.5;cursor:not-allowed;}
    .header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #eef2f7;background:#fff;}
    .app-name{font-weight:700;}
    .disclaimer{font-size:12px;color:#374151;background:#fff7ed;padding:.6rem .8rem;border-radius:.5rem;border:1px solid #fbbf24;margin-top:12px;}
    
    .message-time {
      font-size: 10px;
      color: #9ca3af;
      margin-top: 4px;
      text-align: right;
    }

    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      background: #f0f4f8;
      border-radius: 1rem;
      padding: 0.75rem 1rem;
      max-width: fit-content;
      margin-bottom: 0.5rem;
    }
    .typing-dot {
      width: 8px;
      height: 8px;
      background-color: #94a3b8;
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    /* Full-screen landing page styles */
    .landing-page {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100vw;
      background: #f0f2f5;
      padding: 20px;
    }

    /* Spinning circle animation for logo */
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .spinning-logo {
      border-radius: 50%;
      animation: spin 5s linear infinite;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div id="connection-status" class="small-note">Inicializando...</div>
  </div>

  <!-- SELECCIÓN INICIAL: idioma + rol -->
  <div id="role-selection-screen" class="landing-page">
    <div class="panel" role="dialog" aria-modal="true" style="display:flex;flex-direction:column;gap:12px;">
      <div style="display:flex;flex-direction:column;align-items:center;text-align:center;gap:12px;">
        <img src="https://play-lh.googleusercontent.com/nV-WEi2R84Kv9r6QUq1RY5tc2ZfZW7jSOtnTHktugSZCEVhFYjVRLjxH88Vh_23WMII=w240-h480-rw" alt="logo" class="spinning-logo" style="width:96px;height:96px;object-fit:cover;">
        <div>
          <div class="app-name text-2xl">Inkspired Helped</div>
          <div class="small-note">Soporte no oficial — ayuda y sugerencias para Galo</div>
        </div>
      </div>

      <div style="display:flex;justify-content:center;gap:12px;margin-top:12px;">
        <label for="lang-select" class="small-note" style="margin-right:6px;">Idioma</label>
        <select id="lang-select" class="lang-select" aria-label="Seleccionar idioma">
          <option value="es">Español (es)</option>
          <option value="en">English (en)</option>
          <option value="pt">Português (pt)</option>
          <option value="de">Deutsch (de)</option>
        </select>
      </div>
      
      <div style="display:flex;gap:12px;flex-direction:column;align-items:stretch;margin-top:24px;">
        <button id="user-button" class="btn" style="background:#7c3aed;color:white;font-weight:700;">Continuar como Usuario</button>
        <button id="agent-button" class="btn" style="background:#374151;color:white;font-weight:700;">Entrar como Agente</button>
        <div class="disclaimer">Soporte no oficial: Este chat no es una alianza ni un acuerdo con Inkspired. Soy un ayudante para facilitar procesos y sugerencias que pueden dirigirse a Galo (creador).</div>
      </div>
    </div>
  </div>

  <!-- LOGIN AGENTE -->
  <div id="agent-login-screen" class="center-screen" style="display:none">
    <div class="panel">
      <div style="display:flex;flex-direction:column;gap:12px;">
        <h2 style="margin:0">Acceso de Agente</h2>
        <input id="agent-password-input" type="password" placeholder="Ingresa la clave">
        <div style="display:flex;gap:8px;">
          <button id="agent-login-button" class="btn" style="background:#7c3aed;color:white;">Entrar</button>
          <button id="agent-login-cancel" class="btn" style="background:#e5e7eb;">Cancelar</button>
        </div>
        <div id="password-error" class="small-note" style="color:#dc2626;display:none">Clave incorrecta.</div>
      </div>
    </div>
  </div>

  <!-- INTERFAZ DE CHAT -->
  <div id="chat-screen" style="display:none;flex-direction:column;height:100vh;">
    <div class="header">
      <div class="app-name">Inkspired Helped</div>
      <div id="user-lang-display" class="small-note"></div>
    </div>

    <div id="messages-area" class="chat-container" aria-live="polite"></div>

    <!-- Typing indicator -->
    <div id="typing-indicator" style="display:none;">
      <div class="typing-indicator">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>

    <div style="padding:12px;border-top:1px solid #eef2f7;background:#fff;display:flex;gap:8px;align-items:center;">
      <input id="message-input" type="text" placeholder="Escribe un mensaje..." disabled>
      <button id="send-button" class="btn" style="background:#7c3aed;color:white;" disabled>Enviar</button>
    </div>
  </div>

  <!-- SCRIPT: robusto, no bloqueante -->
  <script type="module">
    // IMPORTS Firebase modular (v11)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getDatabase, ref, push, set, update, onChildAdded, off, query, orderByChild, limitToLast, serverTimestamp, remove, get
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

    document.addEventListener('DOMContentLoaded', () => {
      // UI refs
      const roleSelectionScreen = document.getElementById('role-selection-screen');
      const userButton = document.getElementById('user-button');
      const agentButton = document.getElementById('agent-button');
      const agentLoginScreen = document.getElementById('agent-login-screen');
      const agentLoginBtn = document.getElementById('agent-login-button');
      const agentLoginCancel = document.getElementById('agent-login-cancel');
      const agentPasswordInput = document.getElementById('agent-password-input');
      const passwordError = document.getElementById('password-error');
      const langSelect = document.getElementById('lang-select');

      const chatScreen = document.getElementById('chat-screen');
      const messagesArea = document.getElementById('messages-area');
      const messageInput = document.getElementById('message-input');
      const sendButton = document.getElementById('send-button');
      const connectionStatus = document.getElementById('connection-status');
      const userLangDisplay = document.getElementById('user-lang-display');
      const typingIndicator = document.getElementById('typing-indicator');

      // Configuration
      const LIBRE_TRANSLATE_URL = "https://libretranslate.de/translate"; // fallback public endpoint
      const FIREBASE_CONFIG = {
        apiKey: "AIzaSyCFQ_geG0HIv2EZ-bfKc97TJNtf2sdqPzc",
        authDomain: "clack-koder.firebaseapp.com",
        databaseURL: "https://clack-koder-default-rtdb.firebaseio.com",
        projectId: "clack-koder",
        storageBucket: "clack-koder.firebasestorage.app",
        messagingSenderId: "478151254938",
        appId: "1:478151254938:web:e2c00e3a5426bd192b9023",
        measurementId: "G-P29ME5Z3S1"
      };
      const AGENT_PASSWORD = "Inkspired2025";
      const ARTIFACT_APP_ID = FIREBASE_CONFIG.projectId || 'default-app-id';
      const AI_TIMEOUT_MS = 30000; // 30 segundos para activar la IA

      // State
      let usingRealtime = false;
      let app = null, db = null, auth = null;
      let userId = null;
      let userRole = null; // 'user' | 'agent'
      let selectedChatId = null;
      let chatsListenerRef = null, messagesListenerRef = null;
      let selectedLang = langSelect.value || 'es';
      let isAIActive = false;
      let aiTimer = null;
      const apiKey = "";
      const apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; // Gemini API endpoint

      // Small utilities
      function logInfo(...args){ console.log("[Inkspired]", ...args); }

      function addSystem(text){
        const div = document.createElement('div'); div.className = 'system-bubble message-bubble'; div.innerText = text;
        const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.justifyContent='center'; wrapper.style.marginBottom='8px';
        wrapper.appendChild(div); messagesArea.appendChild(wrapper); messagesArea.scrollTop = messagesArea.scrollHeight;
      }
      
      function formatTimestampToTime(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
      }
      
      const messageCache = new Set();
      function addMessage(text, sender, metaHTML, messageId, timestamp, isOwnMessage){
          if (messageId && messageCache.has(messageId)) {
            logInfo("Mensaje duplicado detectado, ignorando:", messageId);
            return;
          }
          if (messageId) {
            messageCache.add(messageId);
          }

        const wrapper = document.createElement('div');
        wrapper.style.display='flex';
        wrapper.style.marginBottom='8px';
        wrapper.style.alignItems='flex-start';
        if (sender === 'user') {
          wrapper.style.justifyContent='flex-end';
        } else {
          wrapper.style.justifyContent='flex-start';
        }
        
        if (sender !== 'user'){
          const avatar = document.createElement('div');
          avatar.style.width='40px';
          avatar.style.height='40px';
          avatar.style.borderRadius='50%';
          avatar.style.marginRight='8px';
          avatar.style.backgroundImage = "url('https://play-lh.googleusercontent.com/nV-WEi2R84Kv9r6QUq1RY5tc2ZfZW7jSOtnTHktugSZCEVhFYjVRLjxH88Vh_23WMII=w240-h480-rw')";
          avatar.style.backgroundSize = 'cover';
          avatar.style.backgroundPosition='center';
          wrapper.appendChild(avatar);
        } else {
          const spacer = document.createElement('div');
          spacer.style.width='48px';
          wrapper.appendChild(spacer);
        }

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble ' + (sender === 'user' ? 'user-bubble' : (sender === 'agent' ? 'agent-bubble' : 'system-bubble'));
        
        const contentDiv = document.createElement('div');
        contentDiv.innerText = text;
        
        const metaDiv = document.createElement('div');
        metaDiv.style.display = 'flex';
        metaDiv.style.justifyContent = 'flex-end';
        metaDiv.style.alignItems = 'center';
        metaDiv.style.gap = '8px';
        
        const timeSpan = document.createElement('span');
        timeSpan.className = 'message-time';
        timeSpan.innerText = formatTimestampToTime(timestamp);

        metaDiv.appendChild(timeSpan);

        if (metaHTML){
          const small = document.createElement('div');
          small.style.fontSize='12px';
          small.style.color='#6b7280';
          small.style.marginTop='6px';
          small.innerHTML = metaHTML;
          metaDiv.appendChild(small);
        }
        
        bubble.appendChild(contentDiv);
        bubble.appendChild(metaDiv);

        wrapper.appendChild(bubble);
        messagesArea.appendChild(wrapper);
        messagesArea.scrollTop = messagesArea.scrollHeight;

        if(isOwnMessage && messageId && usingRealtime) {
          let lastTouchTime = 0;
          bubble.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTouchTime;

            if (timeDiff < 300 && timeDiff > 0) {
              e.preventDefault();
              logInfo(`Doble toque detectado para eliminar el mensaje con ID: ${messageId}`);
              safeRemove(pathChatMessages(selectedChatId, messageId));
            }
            lastTouchTime = currentTime;
          });
          bubble.addEventListener('dblclick', (e) => {
            e.preventDefault();
            logInfo(`Doble clic detectado para eliminar el mensaje con ID: ${messageId}`);
            safeRemove(pathChatMessages(selectedChatId, messageId));
          });
        }
      }

      function showTypingIndicator() {
        typingIndicator.style.display = 'block';
        messagesArea.scrollTop = messagesArea.scrollHeight;
      }

      function hideTypingIndicator() {
        typingIndicator.style.display = 'none';
      }

      // TRANSLATION: non-blocking helpers
      async function translateWithFallback(text, source, target){
        if (!text || source === target) return text;
        try {
          const r = await fetch(LIBRE_TRANSLATE_URL, {
            method:'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ q:text, source, target, format:'text' })
          });
          const j = await r.json();
          if (j && j.translatedText) return j.translatedText;
          if (Array.isArray(j) && j[0] && j[0].translatedText) return j[0].translatedText;
        } catch(e){ console.warn("LibreTranslate failed:", e); }
        return text;
      }

      async function getAIGeneration(prompt) {
        showTypingIndicator();
        const payload = {
          contents: [{ role: "user", parts: [{ text: prompt }] }],
          systemInstruction: {
            parts: [{ text: "Eres un agente de soporte virtual para Inkspired. Debes responder de manera amigable, profesional y concisa. Si no sabes la respuesta, dirás que lo escalarás a un agente humano en cuanto esté disponible. Tu objetivo es ayudar al usuario de la mejor manera posible." }]
          },
        };

        try {
            const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                console.error("Error en la llamada a la API de IA:", await response.text());
                return "Disculpe, hubo un problema al conectar con el asistente virtual. Por favor, intente de nuevo más tarde.";
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];
            const text = candidate?.content?.parts?.[0]?.text;
            return text || "No pude generar una respuesta en este momento.";
        } catch (e) {
            console.error("Error al obtener respuesta de la IA:", e);
            return "Disculpe, hubo un problema de red. Por favor, intente de nuevo.";
        } finally {
            hideTypingIndicator();
        }
      }

      // FIREBASE safe init
      (async function initRealtime(){
        try {
          app = initializeApp(FIREBASE_CONFIG);
          auth = getAuth(app);
          db = getDatabase(app);
          usingRealtime = true;
          connectionStatus.innerText = "Conexión en tiempo real: OK";
          onAuthStateChanged(auth, async (u) => {
            if (!u) {
              try { await signInAnonymously(auth); } catch(e){ console.warn("signin anon error", e); }
            }
            userId = auth.currentUser?.uid || crypto.randomUUID();
            logInfo("UID", userId);
          });
          logInfo("Firebase inicializado (Realtime)");
        } catch(e){
          usingRealtime = false;
          connectionStatus.innerText = "Modo prueba (sin conexión real)";
          userId = crypto.randomUUID();
          logInfo("No se pudo inicializar Realtime:", e);
          addSystem("La conexión en tiempo real no está disponible — modo prueba activado.");
        }
      })();

      // DB path helpers
      function pathChatsRoot(){ return `artifacts/${ARTIFACT_APP_ID}/public/data/chats`; }
      function pathChat(chatId){ return `${pathChatsRoot()}/${chatId}`; }
      function pathChatMessages(chatId, messageId = ''){ return `${pathChat(chatId)}/messages/${messageId}`; }

      // DB wrappers
      async function safePush(path, payload){
        if (!usingRealtime) return null;
        try {
          const refRes = await push(ref(db, path), payload);
          return refRes?.key || null;
        } catch(e){
          console.error("safePush error", e);
          return null;
        }
      }
      async function safeSet(path, payload){
        if (!usingRealtime) return false;
        try { await set(ref(db, path), payload); return true; } catch(e){ console.error("safeSet error", e); return false; }
      }
      async function safeUpdate(path, payload){
        if (!usingRealtime) return false;
        try { await update(ref(db, path), payload); return true; } catch(e){ console.error("safeUpdate error", e); return false; }
      }
      
      async function safeRemove(path) {
        if (!usingRealtime) return false;
        try {
          await remove(ref(db, path));
          logInfo(`Mensaje eliminado con éxito.`);
          return true;
        } catch(e) {
          console.error(`Error al eliminar el mensaje: ${e}`);
          return false;
        }
      }

      // Listeners management
      function attachChatsListener(onRequest){
        if (!usingRealtime) return;
        detachChatsListener();
        try {
          const r = ref(db, pathChatsRoot());
          const q = query(r, orderByChild('createdAt'), limitToLast(50));
          chatsListenerRef = r;
          onChildAdded(q, (snap) => {
            const data = snap.val();
            if (!data) return;
            if (data.isRequest) onRequest({ chatId: snap.key, ...data });
          });
        } catch(e){ console.error("attachChatsListener error", e); }
      }
      function detachChatsListener(){
        if (!usingRealtime || !chatsListenerRef) return;
        try { off(chatsListenerRef); } catch(e){ console.warn("off chats fail", e); }
        chatsListenerRef = null;
      }

      function attachMessagesListener(chatId, onMessage){
        if (!usingRealtime) return;
        detachMessagesListener();
        try {
          const r = ref(db, pathChatMessages(chatId));
          messagesListenerRef = r;
          onChildAdded(r, (snap) => {
            const id = snap.key;
            if (!id) return;
            const data = snap.val();
            if (!data) return;
            onMessage({ id, ...data });
          });
        } catch(e){ console.error("attachMessagesListener error", e); }
      }
      function detachMessagesListener(){
        if (!usingRealtime || !messagesListenerRef) return;
        try { off(messagesListenerRef); } catch(e){ console.warn("off messages fail", e); }
        messagesListenerRef = null;
      }

      // UI updates for language display
      function refreshUserLangDisplay(){
        const map = { es:'Español', en:'English', pt:'Português', de:'Deutsch' };
        userLangDisplay.innerText = `Idioma: ${map[selectedLang] || selectedLang}`;
      }
      refreshUserLangDisplay();

      // FLOW: Automated assistant steps
      const STEPS_BASE = [
        { text: "Hola, soy un asistente virtual de Inkspired. ¿En qué puedo ayudarte?", sender:'agent', delay:1500 },
        { text: "¿Podrías proporcionarme tu correo electrónico?", sender:'agent', delay:1000, waitForUser:true, placeholder:"Tu correo electrónico...", field:"email" },
        { text: "Por favor, ingresa tu nombre de usuario de Inkspired.", sender:'agent', delay:1000, waitForUser:true, placeholder:"Tu nombre de usuario...", field:"username" },
        { text: "Ahora, por favor, describe brevemente tu problema.", sender:'agent', delay:1000, waitForUser:true, placeholder:"Describe tu problema...", field:"problem" }
      ];
      let STEPS = JSON.parse(JSON.stringify(STEPS_BASE));
      let currentStepIndex = 0, isAutoConversationRunning=false, isWaitingForUserInput=false;
      let userData = {};

      async function runAutoConversation(){
        if (isAutoConversationRunning) return;
        isAutoConversationRunning = true;
        
        while (currentStepIndex < STEPS.length){
          const step = STEPS[currentStepIndex];
          await new Promise(r => setTimeout(r, step.delay));
          
          showTypingIndicator();
          await new Promise(r => setTimeout(r, 1000));
          hideTypingIndicator();

          if(usingRealtime) {
            const payload = { text: step.text, lang: 'es', sender: 'agent', createdAt: serverTimestamp() };
            await safePush(pathChatMessages(selectedChatId), payload);
          } else {
             addMessage(step.text, 'agent', null, null, new Date().getTime(), false);
          }
          if (step.waitForUser){
            messageInput.placeholder = step.placeholder || "Escribe un mensaje...";
            messageInput.disabled = false; sendButton.disabled = false;
            messageInput.focus();
            isWaitingForUserInput = true;
            isAutoConversationRunning = false;
            return;
          }
          currentStepIndex++;
        }
        isAutoConversationRunning = false;
      }
      
      async function startRealChatFlow(problemDescription) {
        if (!selectedChatId) {
            const newChatId = crypto.randomUUID();
            selectedChatId = newChatId;
        }

        const meta = { isRequest:true, username:userData.username||'anónimo', problem:problemDescription || 'No especificado', lang:selectedLang, createdAt: serverTimestamp() };
        if (usingRealtime) {
            const ok = await safeSet(pathChat(selectedChatId), meta);
            if (!ok) {
                addSystem("No se pudo crear la solicitud en la red (ver consola).");
            } else {
                await safePush(pathChatMessages(selectedChatId), { text:`Un usuario (${userData.username||'anónimo'}) con correo (${userData.email||'no especificado'}) solicita chat. Problema: ${problemDescription}.`, sender:'system', isRequest:true, createdAt: serverTimestamp() });
                
                // Start AI timer
                aiTimer = setTimeout(async () => {
                  const chatRef = await get(ref(db, pathChat(selectedChatId)));
                  if (chatRef.exists() && chatRef.val().isRequest) {
                    isAIActive = true;
                    // Update Firebase to mark AI as active
                    await safeUpdate(pathChat(selectedChatId), { isAIActive: true });
                    // Send an introductory message from the AI
                    const aiIntro = "Un agente no está disponible. El asistente virtual tomará la conversación.";
                    await safePush(pathChatMessages(selectedChatId), { text: aiIntro, lang: 'es', sender: 'system', isAI: true, createdAt: serverTimestamp() });
                    const translatedAiIntro = await translateWithFallback(aiIntro, 'es', selectedLang);
                    await safePush(pathChatMessages(selectedChatId), { text: translatedAiIntro, lang: selectedLang, sender: 'agent', isAI: true, createdAt: serverTimestamp() });
                  }
                }, AI_TIMEOUT_MS);
            }
        } else {
            addSystem("Modo prueba: solicitud simulada (sin conexión real).");
            isAIActive = true;
            addSystem("Modo prueba: la IA se ha activado inmediatamente.");
        }

        messageInput.disabled = false;
        sendButton.disabled = false;
        
        if (usingRealtime && selectedChatId){
          attachMessagesListener(selectedChatId, async (m) => {
            if (!m) return;
            const isOwnMessage = m.sender === 'user';
            
            if (m.sender === 'agent' && userRole === 'user'){
              const translated = await translateWithFallback(m.text, 'es', selectedLang).catch(()=>m.text);
              addMessage(translated, 'agent', `<em>(en ${selectedLang})</em>`, m.id, m.createdAt, isOwnMessage);
            } else if (m.sender === 'system') {
                addMessage(m.text, 'system', null, m.id, m.createdAt, false);
            }
            else if (m.sender === 'user' && userRole === 'agent') {
              const src = m.lang || selectedLang;
              const t = await translateWithFallback(m.text, src, selectedLang).catch(()=>m.text);
              addMessage(t, 'user', `<em>(en ${selectedLang})</em>`, m.id, m.createdAt, isOwnMessage);
            }
          });
        }
      }

      function setupAgentPanel(){
        roleSelectionScreen.style.display = 'none';
        agentLoginScreen.style.display = 'none';
        chatScreen.style.display = 'flex';
        messageInput.disabled = false; sendButton.disabled = false;
        userRole = 'agent';

        if (usingRealtime){
          attachChatsListener((request) => {
            selectedChatId = request.chatId;
            messagesArea.innerHTML = '';
            addSystem(`Nueva solicitud recibida de ${request.username || 'anónimo'} (problema: ${request.problem || 'No especificado'}). Escribe /accept para atender.`);
            attachMessagesListener(request.chatId, async (m) => {
              if (!m) return;
              const isOwnMessage = m.sender === 'agent';
              if (m.sender === 'user'){
                const textForAgent = m.text_es || (m.lang ? await translateWithFallback(m.text, m.lang, 'es') : m.text);
                addMessage(textForAgent, 'user', `<em>(Original: ${m.lang || 'desconocido'})</em>`, m.id, m.createdAt, isOwnMessage);
              } else if (m.sender === 'agent') {
                addMessage(m.text, 'agent', null, m.id, m.createdAt, isOwnMessage);
              } else if (m.sender === 'system') {
                addMessage(m.text, 'system', null, m.id, m.createdAt, false);
              }
            });
          });
        } else {
          addSystem("Modo prueba: sin solicitudes reales (conexión inactiva).");
        }
        addSystem("Bienvenido, agente. Canal de soporte no oficial. Esperando solicitudes...");
      }

      // Event listeners UI
      userButton.addEventListener('click', async () => {
        try {
          roleSelectionScreen.style.display = 'none';
          chatScreen.style.display = 'flex';
          userRole = 'user';
          selectedLang = langSelect.value || 'es';
          refreshUserLangDisplay();
          currentStepIndex = 0; userData = {};
          messagesArea.innerHTML = '';
          messageInput.disabled = true; sendButton.disabled = true;

          // NEW LOGIC: Attach listener before sending first message
          if (usingRealtime) {
            const newChatId = crypto.randomUUID();
            selectedChatId = newChatId;
            attachMessagesListener(selectedChatId, async (m) => {
                if (!m) return;
                const isOwnMessage = m.sender === 'user';
                
                if (m.sender === 'agent' && userRole === 'user'){
                  const translated = await translateWithFallback(m.text, 'es', selectedLang).catch(()=>m.text);
                  addMessage(translated, 'agent', `<em>(en ${selectedLang})</em>`, m.id, m.createdAt, isOwnMessage);
                } else if (m.sender === 'system') {
                    addMessage(m.text, 'system', null, m.id, m.createdAt, false);
                }
            });
          }

          await runAutoConversation();
        } catch(e) {
          console.error("userButton click error", e);
          addSystem("Error en interfaz (revisa consola).");
        }
      });

      agentButton.addEventListener('click', () => {
        roleSelectionScreen.style.display = 'none';
        agentLoginScreen.style.display = 'flex';
      });

      agentLoginCancel.addEventListener('click', () => {
        agentLoginScreen.style.display = 'none';
        roleSelectionScreen.style.display = 'flex';
      });

      agentLoginBtn.addEventListener('click', () => {
        const p = agentPasswordInput.value || '';
        if (p === AGENT_PASSWORD){
          passwordError.style.display = 'none';
          setupAgentPanel();
        } else {
          passwordError.style.display = 'block';
        }
      });

      sendButton.addEventListener('click', async () => {
        try {
          const text = messageInput.value.trim();
          if (!text) return;
          messageInput.value = '';
          messageInput.disabled = true;
          sendButton.disabled = true;
          
          if (userRole === 'user'){
            if (isWaitingForUserInput){
              const step = STEPS[currentStepIndex];
              if (step && step.field) userData[step.field] = text;
              isWaitingForUserInput = false;
              currentStepIndex++;
              if (currentStepIndex < STEPS.length) {
                runAutoConversation();
              } else {
                startRealChatFlow(text);
              }
              return;
            }

            if (!selectedChatId){
              addSystem("Aún no se ha creado el chat. Intenta de nuevo en un momento.");
              sendButton.disabled = false; messageInput.disabled = false; return;
            }

            if (isAIActive) {
                const aiResponse = await getAIGeneration(text);
                if (usingRealtime) {
                    const translatedText = await translateWithFallback(aiResponse, 'es', selectedLang).catch(()=>aiResponse);
                    const payload = { text: translatedText, lang: selectedLang, text_es: aiResponse, sender: 'agent', isAI: true, createdAt: serverTimestamp() };
                    await safePush(pathChatMessages(selectedChatId), payload);
                } else {
                  addMessage(aiResponse, 'agent', null, null, new Date().getTime(), false);
                }
            } else {
                // Mensaje a agente humano
                if (usingRealtime){
                  const text_es = await translateWithFallback(text, selectedLang, 'es').catch(()=>text);
                  const payload = { text, lang: selectedLang, text_es, sender:'user', createdAt: serverTimestamp() };
                  await safePush(pathChatMessages(selectedChatId), payload);
                }
            }
          } else if (userRole === 'agent'){
            if (!selectedChatId){
              addSystem("No hay chat seleccionado.");
              sendButton.disabled = false; messageInput.disabled = false; return;
            }
            if (text.toLowerCase() === '/accept'){
              if (usingRealtime){
                clearTimeout(aiTimer);
                await safeUpdate(pathChat(selectedChatId), { isRequest:false, isAIActive: false, agentId:userId, acceptedAt: serverTimestamp() });
                await safePush(pathChatMessages(selectedChatId), { text: "El agente se ha unido a la conversación.", sender:'system', createdAt: serverTimestamp() });
              } else addSystem("(prueba) chat aceptado");
              messageInput.placeholder = "Escribe tu respuesta...";
              messageInput.value = '';
              sendButton.disabled = false; messageInput.disabled = false;
              return;
            }

            if (usingRealtime){
              const payload = { text, lang:'es', sender:'agent', createdAt: serverTimestamp() };
              await safePush(pathChatMessages(selectedChatId), payload);
            }
          } else {
            addSystem("Selecciona un rol antes de enviar.");
          }
        } catch(e){
          console.error("send handler error", e);
          addSystem("Error enviando mensaje (ver consola).");
        } finally {
          sendButton.disabled = false; messageInput.disabled = false;
        }
      });

      // Enter key shortcut
      messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendButton.click(); });

      // language selector change: update selectedLang and visible label immediately
      langSelect.addEventListener('change', () => {
        selectedLang = langSelect.value;
        refreshUserLangDisplay();
      });

      // initial UI ready
      connectionStatus.innerText = "Sistema listo";
      addSystem("Sistema listo. Modo: " + (usingRealtime ? "Conexión en tiempo real" : "Modo prueba (sin conexión)"));

      // cleanup listeners on unload
      window.addEventListener('beforeunload', () => {
        try { detachChatsListener(); detachMessagesListener(); } catch(e){ /* noop */ }
      });

      // detach helpers
      function detachChatsListener(){ if (usingRealtime && chatsListenerRef) try{ off(chatsListenerRef); } catch(e){} chatsListenerRef=null; }
      function detachMessagesListener(){ if (usingRealtime && messagesListenerRef) try{ off(messagesListenerRef); } catch(e){} messagesListenerRef=null; }

      // Final log
      logInfo("Interfaz inicializada, listo para interacción.");
    }); // DOMContentLoaded end
  </script>
</body>
</html>

